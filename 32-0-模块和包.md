---
title: 32-0-模块和包
url: 32-0-模块和包
author: YJ2CS
avatar: '/custom/avatar.webp'
authorLink: YJ2CS.github.io
authorAbout: 愿青年摆脱了冷气，只是向前走！
authorDesc: 愿青年摆脱了冷气，只是向前走！
comments: true
categories:
  - 文章
tags:
  - 悦读
no-photos: 'https://random.52ecy.cn/randbg.php?size=1&rid-1ddc'
date: 2020-12-14T21:12:09.000Z
date updated: '2020-12-23T14:20:13+08:00'

---

### 一.模块和包

你们听到的包,可不是女同胞疯狂喜欢的那个包,我们来看看这个是啥包
官方解释:

    Packages are a way of structuring Python’s module namespace by using “dotted module names”
    包是一种通过使用.模块名来组织python模块名称空间的方式。

    具体的：包就是一个包含有__init__.py文件的文件夹，所以其实我们创建包的目的就是为了用文件夹将文件/模块组织起来

    需要强调的是：
    　　1. 在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错

    　　2. 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包的本质就是一种模块

为什么要使用包呢?
包的本质就是一个文件夹，那么文件夹唯一的功能就是将文件组织起来
随着功能越写越多，我们无法将所以功能都放到一个文件中，于是我们使用模块去组织功能，而随着模块越来越多，我们就需要用文件夹将模块文件组织起来，以此来提高程序的结构性和可维护性

注意事项

    #1.关于包相关的导入语句也分为import和from ... import ...两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如item.subitem.subsubitem,但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。

    #2、import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件

    #3、包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间

包的使用
示例文件

```
bake            

	├── __init__.py       

	├── api               

		├── __init__.py

		├── policy.py

		└── versions.py

  ├── cmd             

    ├── __init__.py

    └── manage.py

  └── db                

      ├── __init__.py

      └── models.py
    
```

包所包含的文件内容

```
#policy.py
def get():
    print('from policy.py')

#versions.py
def create_resource(conf):
    print('from version.py: ',conf)

#manage.py
def main():
    print('from manage.py')

#models.py
def register_models(engine):
    print('from models.py: ',engine)

```

执行文件与包在同级

#### 包的使用之import

    import bake.cmd.manage
    bake.cmd.manage.main()

单独导入包名称时不会导入包中所有包含的所有子模块，如下操作

    #在与bake同级的test.py中
    import bake
    bake.cmd.manage.main()

    '''
    执行结果：
    AttributeError: module 'bake' has no attribute 'cmd'
    '''

解决方法：

```tree
bake
├── __init__.py
├── api
│   ├── __init__.py
│   ├── policy.py
│   └── versions.py
├── cmd
│   ├── __init__.py
│   └── manage.py
└── db
    ├── __init__.py
    └── models.py
```

在bake文件下的__init___.py中添加

```python
from . import cmd
```

在cmd文件夹下的__init__.py中添加

```python
from . import manage
```

执行：

    在于bake同级的test文件夹中的bake_test.py进行导入
    import bake
    bake.cmd.manage.main()
    # 结果
    from manage.py

#### 包的使用之from ... import ...

需要注意的是from后import导入的模块，必须是明确的,一个点都不能带，否则会有语法错误，如：from a import b.c是错误语法

from bake.api import *

在讲模块时，我们已经讨论过了从一个模块内导入所有，此处我们研究从一个包导入所有。

此处是想从包bake中导入所有，实际上该语句只会导入包bake下__init__**.py文件中定义的名字，我们可以在这个文件中定义__all__**:

```python
#bake包下的__init__.py中定义
__all__=['cmd','db']
from . import api
from . import db
from . import cmd
```

此时我们在于bake同级的文件中执行 ` import bake  `就导入bake包下的__all__中的内容（api的包就能不能导入）。

```python
#bake包下的__init__.py中定义
__all__=['cmd','db']
from . import api
from . import db
from . import cmd
```

此时我们在于bake同级的文件中执行`from bake import *`就导入bake包下的__all__中的内容（api的包仍然能不能导入）

```python
#bake包下的__init__.py中定义
__all__=['cmd','db']
from . import api
from . import db
from . import cmd
```

此时我们在于bake同级的文件中执行`from bake.api import *`就导入bake包下的__all__中的内容（api的包就能够导入）

```python
#api包下的__init__.py中定义
__all__ = ["policy"]
from . import versions
from . import policy
```

此时我们在于bake同级的文件中执行 ` from bake.api import *  `就导入bake包下的__all__中的内容（versions就不能够导入）

```python
#api包下的__init__.py中定义
__all__ = ["policy"]
from . import versions
from . import policy
```

此时我们在于bake同级的文件中执行 ` from bake.api import versions  `就导入bake包下的__all__中的内容（versions就能够导入）

总结:

    我们之前操作模块的时候,限制全部导入在当前模块进行限制

    包操作的时候,限制全部导入需要在包下的\_\_init\_\_.py中进行限制

    之前学习的模块就是模块的本身,模块可以自己控制自己,包需要一个\_\_init\_\_.py来进行控制.

练习：

    #在bake同级的文件中使用效果如下，请处理好包的导入
    from bake import *

    get()
    create_resource('a.conf')
    main()
    register_models('mysql')

解决方法:

```python
#在bake.__init__.py中
from .api.policy import get
from .api.versions import create_resource
from .cmd.manage import main
from .db.models import  register_models
```

#### 绝对导入和相对导入

我们的最顶级包bake是写给别人用的，然后在bake包内部也会有彼此之间互相导入的需求，这时候就有绝对导入和相对导入两种方式：

绝对导入：以bake作为起始

相对导入：用.或者..的方式最为起始 [.是当前目录 ..是父级目录]（只能在一个包中使用，不能用于不同目录内）

例如：我们在bake/api/version.py中想要导入bake/cmd/manage.py

    1 在bake/api/version.py
    2 
    3 #绝对导入
    4 from bake.cmd import manage
    5 manage.main()
    6 
    7 #相对导入
    8 from ..cmd import manage
    9 manage.main()

注意在使用相对路径的时候一定要在于bake同级的文件中测试

包以及包所包含的模块都是用来被导入的，而不是被直接执行的。而环境变量都是以执行文件为准的

比如我们想在bake/api/versions.py中导入bake/api/policy.py，有的同学一抽这俩模块是在同一个目录下，十分开心的就去做了，它直接这么做

    1 #在version.py中
    2 
    3 import policy
    4 policy.get()

没错，我们单独运行version.py是一点问题没有的，运行version.py的路径搜索就是从当前路径开始的，于是在导入policy时能在当前目录下找到

但是你想啊，你子包中的模块version.py极有可能是被一个bake包同一级别的其他文件导入，比如我们在于bake同级下的一个test.py文件中导入version.py，如下

     1 from bake.api import versions
     2 
     3 '''
     4 执行结果:
     5 ImportError: No module named 'policy'
     6 '''
     7 
     8 '''
     9 分析:
    10 此时我们导入versions在versions.py中执行
    11 import policy需要找从sys.path也就是从当前目录找policy.py,
    12 这必然是找不到的
    13 '''

绝对导入与相对导入总结

    绝对导入与相对导入

    # 绝对导入: 以执行文件的sys.path为起始点开始导入,称之为绝对导入
    #        优点: 执行文件与被导入的模块中都可以使用
    #        缺点: 所有导入都是以sys.path为起始点,导入麻烦

    # 相对导入: 参照当前所在文件的文件夹为起始开始查找,称之为相对导入
    #        符号: .代表当前所在文件的文件加,..代表上一级文件夹,...代表上一级的上一级文件夹
    #        优点: 导入更加简单
    #        缺点: 只能在导入包中的模块时才能使用
    　　　　  #注意:
    　　　　　　　　1. 相对导入只能用于包内部模块之间的相互导入,导入者与被导入者都必须存在于一个包内
    　　　　　　　　2. attempted relative import beyond top-level package # 试图在顶级包之外使用相对导入是错误的,言外之意,必须在顶级包内使用相对导入,每增加一个.代表跳到上一级文件夹,而上一级不应该超出顶级包
